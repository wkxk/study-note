# Part3 **Vue.js 框架源码与进阶**

# 一、手写 Vue Router、手写响应式实现、虚拟 DOM 和 Diff 算法

## 1.vue-router的实现原理

### 1.1 路由规则中的props属性，可以设置动态路由的入参

路由规则中设置如下：

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const routes = [
  ...
  {
    path: '/c/:id',
    // 动态路由通过设置props属性，可以在子组件中通过props属性获取
    props: true,
    name: 'IndexC',
    component: () => import('../pages/c.vue')
  },
]

const router = new VueRouter({
  routes
})
export default router
```

子组件中获取动态路由的id：

```vue
<template>
  <div class="wrapper">c</div>
</template>

<script>
export default {
  components: {},
  // 获取动态路由的id
  props: ['id'],
  data() {
    return {
    };
  },
  created() {},
  mounted() {},
  methods: {},
  computed: {},
  watch: {},
};
</script>
```

推荐使用此方法传递动态路由的id，可以避免去依赖$route。

### 1.2 嵌套路由的使用

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Index from '../pages/a.vue'

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Index',
    component: Index,
    // children属性设置嵌套路由
    children: [
      {
        path: '',
        name: 'IndexB',
        component: () => import('../pages/b.vue')
      },
      {
        path: 'c/:id',
        // 动态路由通过设置props属性，可以在子组件中通过props属性获取
        props: true,
        name: 'IndexC',
        component: () => import('../pages/c.vue')
      },
    ]
  }
  ...
]

const router = new VueRouter({
  routes
})
export default router
```

### 1.3 编程式导航

```js
this.$router.push('/')
this.$router.replace('/')
this.$router.go(-1)
this.$router.back()
...
```

### 1.4 hash模式和history模式的区别

- hash模式是基于锚点，以及onhashchange事件 
- history模式是基于HTML5中的History API
  - history.pushState() IE 10 以后的才支持
  - history.replaceState()
- history模式的使用：
  - 需要服务端配置，否则刷新时出现404